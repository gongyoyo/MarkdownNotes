# 数据结构


- [数据结构](#数据结构)
  - [基础](#基础)
  - [线性表](#线性表)
  - [栈与队列](#栈与队列)
  - [串,字符串](#串字符串)
  - [树](#树)
  - [Merkle Tree](#merkle-tree)

## 基础

1. 逻辑结构
   1. 集合结构
   2. 线性结构
   3. 数形结构
   4. 图形结构
2. 物理结构
   1. 线性存储结构
   2. 链式存储结构
3. 算法的五种基本特性：输入，输出，有穷性，确定性和可行性

## 线性表

1. 数组
2. 单链表
   1. 头插法
   2. 尾插法
3. 静态链表
   1. 用数组描述的链表
   2. 使用游标实现法，数组的每个下标都对应着一个data和cur，cur存放后继元素在数组的下标
   3. 数组建立大一些，未使用的数组称为备用链表，数组第一个和最后一个作为特殊元素，第一个元素存放备用链表的第一个节点的下标，最后一个元素存放第一个有值的元素的下标
   4. 静态链表的申请和释放
      1. 将所有未被使用过的及已删除的游标分量用游标链成一个备用的链表，每当进行插入时，便可以从备用链表上取得一个节点作为待插入的新节点
   5. 循环链表
      1. 将单链表中终端的指针右空指针改为指向头节点
      2. 尾指针
   6. 双向链表
      1. 在单链表的每个结构中，再设置一个指向其前驱节点的指针域
      2. 在插入和删除使指针的更改顺序至关重要

## 栈与队列

栈是限定只在表尾进行插入和删除操作的线性表  
队列是只允许在一端插入，而在另一端删除的线性表
1. 顺序栈,Stack
   1. 栈顶，栈底,后进先出;进栈，压栈，入栈；出栈
   2. 一般用数组，长度为-1时为空
   3. *两栈共享空间*,一般使用在有相反需求的关系时
2. 链栈
3. 栈的应用
   1. 递归
   2. 四则运算，遇左括号入栈，遇右括号出顶栈,运算结果进栈
      1. 后缀表达式`9+(3-1)*3+10/2`, `9 3 1 - 3 * + 10 2 / +`
      2. 中缀表达式转后缀表达式:从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止
4. 队列，First in first out,允许插入的一端称队尾，允许删除的一端称队头,尾指针一般指向队尾的下一个元素，当头指针等于尾指针时说明队列位空
5. 循环队列：头尾相接的顺序存储结构组成的队列
   1. 队满判断：设置一个标志变量；修改队满条件，保留一个空元素,此时判定条件为`(rear+1)%QueueSize=front`,队列长度计算公式为`(rear-front+QueueSize)%QueueSize`
6. 链队列

## 串,字符串

ASCII： 7位二进制->扩展为8位二进制  
UNICODE： 16位二进制  
1. 串的顺序存储
2. 串的链式存储,一个节点可以存储多个字符，最后一个节点未满时使用结束符
3. 朴素的匹配模式算法
   1. 对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配，对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止,时间复杂度位O{(n-m+1)*m},m为子串长度
   2. 如在00000001中查找001
4. KMP模式匹配算法
   1. 假设`S="abcabcabc",T="abcabx"`,i为循环中S主串当前位置的下标，j为子串当前位置的下标(j从1开始？)
   2. 主要为求next[j]的值:next[j]表示当前模式串T的j下标对目标串S的i值失配时，我们应该使用模式串的下标为next[j]接着去和目标串失配的i值进行匹配
   3. next[j]={0,j=1;max{k|1<k<j, $p_1,p_2,...,p_{k-1}=p_{j-k+1},p_{j-k+2},...,p_{j-1}$}}
   4. `T="ababaaaba",next="011234223"`
$$
        next[j] =
        \begin{cases}
        0,  & \text{j=1} \\
        max\{ k | 1<k<j, p_1,p_2,...,p_{k-1}=p_{j-k+1},p_{j-k+2},...,p_{j-1}\} \\
        1,  & \text{其他} \\
        \end{cases}
$$

## 树

树是n(n>=0)个节点的有限集。n=0时称为空树，在任意一个非空树中：
1. 有且仅有一个特定的称为根(root)的节点
2. 当n>1时，其余节点可分为m(m>0)个互不相交的有限集$T_1,T_2,...,T_m$,其中每一个集合本身又是一颗树，并且称为根的子树(SubTree)

1. 节点分类
   1. 节点拥有的子树数称为度(Degree)
   2. 度为0的节点称为叶节点或终端节点(Leaf);度不为0的节点称为分支节点；除根节点以外，分支节点也称为内部节点
   3. 树的度是树内各节点度的最大值
2. 节点的层次(Level)
   1. 根为第一层
   2. 节点的最大层次称为树的深度(Depth)
3. 有序树与无序树；森林
4. 树的顺序存储结构
   1. 双亲表示法:根的双亲域设置为-1;可以扩展增加长子域，兄弟域等
   2. 孩子表示法:把每个节点的孩子节点排列起来，以单链表作为存储结构，则n个节点有n个孩子链表，如果是叶子节点则此单链表为空，然后n个头指针又组成一个线性表，采用顺序存储结构,存放入一个一维数组
      1. 每个节点有多个指针域，其中每个指针指向一颗子树的根节点
      2. 指针域的个数等于树的度
      3. 每个节点指针域的个数等于该节点的度，专门取一个位置来存储节点指针域的个数
   3. 孩子兄弟表示法:任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的
      1. 把复杂的一棵树变成了二叉树
5. 二叉树(Binary Tree)是n(n>=0)个节点的有限集合，该集合或者为空集，或者由一个根节点和两颗互不交叉的，分别称为根节点的左子树与右子树的二叉树组成
   1. 每个节点最多有两颗子树
   2. 左子树与右子树是有顺序的，不能任意颠倒
   3. 即使树中某节点只有一颗子树，也要区分是左子树还是右子树
6. 特殊二叉树
   1. 斜树
   2. 满二叉树:所有分支节点都存在左右子树，并且所有叶子节点都在同一层上
   3. 完全二叉树:对一颗具有n个节点的二叉树按层序编号(根节点为1，同层节点从左向右增大序号)，如果编号位i(1<=i<=n)的节点与同样深度的满二叉树中编号为i的节点在二叉树中的位置完全相同，则这颗树称为完全二叉树
      1. 叶子节点只能出现在最下两层
      2. 最下层的叶子一定集中在左部连续位置
      3. 倒数二层，若有叶子节点，一定在右部连续位置
      4. 如果节点度为1，则该节点只有左孩子，即不存在只有右子树的情况
      5. 同样节点的二叉树，完全二叉树的深度最小
7. 二叉树的性质
   1. 在二叉树的i层，至多有$2^{i-1}$个节点
   2. 深度为k的二叉树，至多有$2^k-1$个节点
   3. 对于一颗二叉树T,如果其终端节点树为$n_0$,度为2的节点数为$n_2$,则$n_0=n_2+1$;根据分支线总数与节点总数推算得到;$分支线总数=n-1=n_1+2n_2, n=n_0+n_1+n_2$
   4. 具有n个节点的完全二叉树的深度为$[log_2n] + 1([x]表示不大于x的最大整数)$
   5. 如果对一颗有n个节点的完全二叉树的节点按层序编号，对任一节点i(1<=i<=n)有
      1. 如果i=1，则节点i是二叉树的根，无双亲，若i>1,则其双亲节点是[i/2]
      2. 如果2i>n,则节点i无左孩子(节点i为叶子节点)，否则其左孩子是节点2i
      3. 如果2i+1>n,则节点i无右孩子，否则其右孩子为2i+1
8. 二叉树的存储结构
   1. 顺序存储结构，完全二叉树，按序号存储，不存在的节点为空
   2. 链式存储结构
9. 遍历二叉树
   1.  二叉树的遍历(traversing binary tree)是指从根节点出发，按照某种次序依次访问二叉树中的所有节点，使得每个节点被访问一次且仅被访问一次
   2.  前序遍历: 若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树
   3.  中序遍历: 若二叉树为空，则空操作返回，否则从根节点开始(注意并不是先访问根节点),中序遍历根节点的左子树，然后访问根节点，最后中序遍历右子树
   4.  后序遍历: 若二叉树为空，则空操作返回，否则从左到右先叶子后节点的方式遍历访问左右子树，最后是访问根节点
   5.  层序遍历: 若二叉树为空，则空操作返回，否则从树的第一层，也就是根节点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对节点逐个访问
   6.  遍历性质
       1.  已知前序遍历序列和中序遍历序列，可以确定唯一一颗二叉树
       2.  已知后序遍历序列和中序遍历序列，可以确定唯一一颗二叉树
       3.  已知前序和后序，是不能确定唯一一颗二叉树的，例如：前序序列ABC，后序序列CBA
10. 二叉树的建立
    1.  扩展二叉树：将二叉树的每个节点的空指针引出一个虚拟节点，其值为一特定值，比如"#",扩展二叉树可以做到一个遍历序列确定一颗二叉树
    2.  根据这个序列比如：AB#D##C##为前序序列，输入程序递归解析就可得到一颗二叉树
11. 线索二叉树
    1.  对于一个有n个节点的二叉链表，每个节点都有指向左右还在的指针域，一共2n个指针域，而n个节点的二叉树共有n-1条分支线，总共存在2n-(n-1)=n+1空指针域
    2.  指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树(Threaded Binary Tree).前驱后后继根据遍历顺序的不同而不同
    3.  对二叉树以某种次序遍历使其变为线索二叉树的过程称为线索化
    4.  为了区别lchild是左孩子还是前驱，需要增加一个ltag，同样，需要增加一个rtag


## Merkle Tree

- Hash
    + Hash是一个把任意长度的数据映射成固定长度数据的函数
- Hash List(Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree)
- Merkle Tree
    + MT是一种树，大多数是二叉树，也可以多叉树，无论是几叉树，它都具有树结构的所有特点
    + Merkle Tree的叶子节点的value是数据集合的单元数据或者单元数据HASH
    + 非叶子节点的value是根据它下面所有的叶子节点值，然后按照Hash算法计算而得出的