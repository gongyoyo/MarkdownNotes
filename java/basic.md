## 基础

- byte 字节 8位二进制
    + char 1
    + short 2
    + int 4
    + long 8
    + float 4
    + double 8

- 有符号位(从0开始)，无符号位

- byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性
- 当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。

- 原码，反码，补码
    + 原码就是符号位加上真值的绝对值， 即用第一位表示符号， 其余位表示值
    + 反码的表示方法是:正数的反码是其本身；负数的反码是在其原码的基础上， 符号位不变，其余各个位取反
    + 补码的表示方法是:正数的补码就是其本身；负数的补码是在其原码的基础上， 符号位不变， 其余各位取反， 最后+1。 (即在反码的基础上+1)
- -0没有必要，所以-0的补码表示-128
- 采用补码运算，所得结果仍为补码
- 溢出只能出现在两个同符号数相加或两个异符号数相减的情况下

- 数据存储机制
    + 正数存储二进制原码
    + 负数存储二进制的补码
    + 补码是<font color='red'>负数的绝对值反码(正数的反码)</font>加1


- java中的<<（左移）、>>（带符号右移）和>>>（无符号右移）
    + << 丢弃最高位，0补最低位
    + \>\>符号位不变，左边补上符号位
    + \>\>\>忽略符号位扩展，0补最高位